{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implementasi Class dan Object Dasar",
        "description": "Membuat class Animal sederhana dengan properties dan method dasar untuk memahami konsep class sebagai blueprint dan object sebagai instance.",
        "details": "Buat file animal.js di folder step-01-classes dengan struktur berikut:\n\n```javascript\nclass Animal {\n  // Properties\n  name;\n  type;\n  sound;\n  \n  // Method untuk menampilkan suara hewan\n  makeSound() {\n    console.log(`${this.name} (${this.type}) berbunyi: ${this.sound}`);\n  }\n}\n\n// Membuat beberapa instance dari class Animal\nconst kucing = new Animal();\nkucing.name = 'Meong';\nkucing.type = 'Kucing';\nkucing.sound = 'Meow';\n\nconst anjing = new Animal();\nanjing.name = 'Doggy';\nanjing.type = 'Anjing';\nanjing.sound = 'Woof';\n\nconst sapi = new Animal();\nsapi.name = 'Moo';\nsapi.type = 'Sapi';\nsapi.sound = 'Moooo';\n\n// Memanggil method untuk setiap hewan\nkucing.makeSound();\nanjing.makeSound();\nsapi.makeSound();\n\n// Contoh eksplorasi mandiri\nconsole.log('\\nContoh eksplorasi mandiri:');\nconst kambing = new Animal();\nkambing.name = 'Billy';\nkambing.type = 'Kambing';\nkambing.sound = 'Mbeeek';\nkambing.makeSound();\n```\n\nTambahkan juga komentar yang menjelaskan konsep class dan object untuk membantu pemahaman.",
        "testStrategy": "Jalankan file dengan Node.js dan verifikasi output yang menampilkan nama, tipe, dan suara dari setiap hewan. Pastikan setiap hewan memiliki karakteristik yang independen dan method makeSound() berfungsi dengan benar untuk semua instance.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implementasi Constructor dan Method dengan State",
        "description": "Mengembangkan class Animal dengan constructor untuk inisialisasi dan method yang dapat mengubah state object.",
        "details": "Buat file animal.js di folder step-02-constructor dengan struktur berikut:\n\n```javascript\nclass Animal {\n  // Properties\n  name;\n  type;\n  sound;\n  hunger = 50; // Level kelaparan awal\n  energy = 100; // Level energi awal\n  \n  // Constructor untuk inisialisasi\n  constructor(name, type, sound) {\n    this.name = name;\n    this.type = type;\n    this.sound = sound;\n    console.log(`Hewan baru dibuat: ${this.name} (${this.type})`);\n  }\n  \n  // Method untuk menampilkan suara\n  makeSound() {\n    console.log(`${this.name} berbunyi: ${this.sound}`);\n    this.energy -= 5; // Mengurangi energi saat bersuara\n    console.log(`Energi ${this.name} sekarang: ${this.energy}`);\n  }\n  \n  // Method untuk memberi makan hewan\n  feed(foodAmount) {\n    this.hunger -= foodAmount;\n    if (this.hunger < 0) this.hunger = 0;\n    console.log(`${this.name} diberi makan. Level kelaparan: ${this.hunger}`);\n  }\n  \n  // Method untuk bermain dengan hewan\n  play(minutes) {\n    this.energy -= minutes * 2;\n    this.hunger += minutes;\n    console.log(`${this.name} bermain selama ${minutes} menit.`);\n    console.log(`Energi: ${this.energy}, Kelaparan: ${this.hunger}`);\n  }\n  \n  // Method untuk menampilkan status hewan\n  showStatus() {\n    return `${this.name} - Energi: ${this.energy}, Kelaparan: ${this.hunger}`;\n  }\n}\n\n// Membuat instance dengan constructor\nconst kucing = new Animal('Meong', 'Kucing', 'Meow');\nconst anjing = new Animal('Doggy', 'Anjing', 'Woof');\n\n// Menggunakan method yang mengubah state\nkucing.makeSound();\nkucing.feed(20);\nkucing.play(10);\nconsole.log(kucing.showStatus());\n\nanjing.makeSound();\nanjing.feed(15);\nanjing.play(5);\nconsole.log(anjing.showStatus());\n```\n\nTambahkan komentar yang menjelaskan konsep constructor dan bagaimana method dapat mengubah state object.",
        "testStrategy": "Jalankan file dengan Node.js dan verifikasi bahwa constructor menginisialisasi object dengan benar. Uji setiap method dan pastikan state object (hunger dan energy) berubah sesuai dengan yang diharapkan. Verifikasi bahwa setiap instance memiliki state yang terpisah.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implementasi Encapsulation dengan Private Properties",
        "description": "Menerapkan konsep encapsulation dengan menggunakan private properties dan getter/setter methods untuk mengontrol akses data.",
        "details": "Buat file animal.js di folder step-03-encapsulation dengan struktur berikut:\n\n```javascript\nclass Animal {\n  // Private properties menggunakan # symbol\n  #name;\n  #type;\n  #sound;\n  #health = 100;\n  #energy = 100;\n  #hunger = 50;\n  \n  constructor(name, type, sound) {\n    this.#name = name;\n    this.#type = type;\n    this.#sound = sound;\n    console.log(`Hewan baru dibuat: ${this.#name} (${this.#type})`);\n  }\n  \n  // Getter methods\n  getName() {\n    return this.#name;\n  }\n  \n  getType() {\n    return this.#type;\n  }\n  \n  getHealth() {\n    return this.#health;\n  }\n  \n  getEnergy() {\n    return this.#energy;\n  }\n  \n  getHunger() {\n    return this.#hunger;\n  }\n  \n  // Setter methods dengan validasi\n  setName(name) {\n    if (name.length > 0) {\n      this.#name = name;\n      return true;\n    }\n    console.log('Nama tidak valid!');\n    return false;\n  }\n  \n  setHealth(health) {\n    if (health >= 0 && health <= 100) {\n      this.#health = health;\n      return true;\n    }\n    console.log('Health harus antara 0-100!');\n    return false;\n  }\n  \n  setEnergy(energy) {\n    if (energy >= 0 && energy <= 100) {\n      this.#energy = energy;\n      return true;\n    }\n    console.log('Energy harus antara 0-100!');\n    return false;\n  }\n  \n  // Methods yang menggunakan private properties\n  makeSound() {\n    if (this.#energy < 10) {\n      console.log(`${this.#name} terlalu lelah untuk bersuara.`);\n      return;\n    }\n    console.log(`${this.#name} berbunyi: ${this.#sound}`);\n    this.#energy -= 5;\n  }\n  \n  feed(amount) {\n    const newHunger = this.#hunger - amount;\n    this.#hunger = newHunger < 0 ? 0 : newHunger;\n    console.log(`${this.#name} diberi makan. Kelaparan: ${this.#hunger}`);\n  }\n  \n  showStatus() {\n    return `${this.#name} - Health: ${this.#health}, Energy: ${this.#energy}, Hunger: ${this.#hunger}`;\n  }\n}\n\n// Membuat instance\nconst kucing = new Animal('Meong', 'Kucing', 'Meow');\n\n// Menggunakan getter dan setter\nconsole.log(`Nama: ${kucing.getName()}`);\nkucing.setName('Kitty');\nconsole.log(`Nama baru: ${kucing.getName()}`);\n\n// Mencoba setter dengan validasi\nkucing.setHealth(50); // Valid\nconsole.log(`Health: ${kucing.getHealth()}`);\nkucing.setHealth(150); // Invalid\n\n// Mencoba akses private property (akan error)\ntry {\n  console.log(kucing.#name); // Uncomment untuk melihat error\n} catch (error) {\n  console.log('Error: Tidak bisa akses private property langsung!');\n}\n\n// Menggunakan methods\nkucing.makeSound();\nkucing.feed(20);\nconsole.log(kucing.showStatus());\n```\n\nTambahkan komentar yang menjelaskan konsep encapsulation dan pentingnya private properties.",
        "testStrategy": "Jalankan file dengan Node.js dan verifikasi bahwa private properties tidak dapat diakses langsung dari luar class. Uji getter dan setter methods, pastikan validasi berfungsi dengan benar. Verifikasi bahwa methods yang menggunakan private properties berfungsi sebagaimana mestinya.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implementasi Inheritance dengan Class Hierarchy",
        "description": "Menerapkan konsep inheritance dengan membuat class Cat dan Dog yang mewarisi dari class Animal.",
        "details": "Buat tiga file di folder step-04-inheritance:\n\n1. animal.js:\n```javascript\nclass Animal {\n  #name;\n  #type;\n  #sound;\n  #energy = 100;\n  #hunger = 50;\n  \n  constructor(name, type, sound) {\n    this.#name = name;\n    this.#type = type;\n    this.#sound = sound;\n    console.log(`Hewan baru dibuat: ${this.#name} (${this.#type})`);\n  }\n  \n  // Getters\n  getName() { return this.#name; }\n  getType() { return this.#type; }\n  getSound() { return this.#sound; }\n  getEnergy() { return this.#energy; }\n  getHunger() { return this.#hunger; }\n  \n  // Methods\n  makeSound() {\n    console.log(`${this.#name} berbunyi: ${this.#sound}`);\n    this.#energy -= 5;\n  }\n  \n  feed(amount) {\n    this.#hunger = Math.max(0, this.#hunger - amount);\n    console.log(`${this.#name} diberi makan. Kelaparan: ${this.#hunger}`);\n  }\n  \n  move() {\n    console.log(`${this.#name} bergerak.`);\n    this.#energy -= 10;\n    this.#hunger += 5;\n  }\n  \n  showStatus() {\n    return `${this.#name} - Energy: ${this.#energy}, Hunger: ${this.#hunger}`;\n  }\n}\n\nmodule.exports = Animal;\n```\n\n2. cat.js:\n```javascript\nconst Animal = require('./animal');\n\nclass Cat extends Animal {\n  constructor(name) {\n    // Memanggil constructor parent dengan super()\n    super(name, 'Kucing', 'Meow');\n    console.log(`${name} adalah seekor kucing!`);\n  }\n  \n  // Cat memiliki semua method dari Animal\n  // Kita bisa menambahkan method khusus untuk Cat\n  scratch() {\n    console.log(`${this.getName()} menggaruk-garuk.`);\n  }\n  \n  climb() {\n    console.log(`${this.getName()} memanjat pohon.`);\n  }\n}\n\nmodule.exports = Cat;\n```\n\n3. dog.js:\n```javascript\nconst Animal = require('./animal');\n\nclass Dog extends Animal {\n  constructor(name) {\n    // Memanggil constructor parent dengan super()\n    super(name, 'Anjing', 'Woof');\n    console.log(`${name} adalah seekor anjing!`);\n  }\n  \n  // Dog memiliki semua method dari Animal\n  // Kita bisa menambahkan method khusus untuk Dog\n  fetch() {\n    console.log(`${this.getName()} mengambil bola.`);\n  }\n  \n  guard() {\n    console.log(`${this.getName()} menjaga rumah.`);\n  }\n}\n\nmodule.exports = Dog;\n```\n\nBuat juga file index.js untuk menguji inheritance:\n```javascript\nconst Animal = require('./animal');\nconst Cat = require('./cat');\nconst Dog = require('./dog');\n\n// Membuat instance dari parent class\nconst genericAnimal = new Animal('Generic', 'Unknown', 'Sound');\ngenericAnimal.makeSound();\ngenericAnimal.move();\nconsole.log(genericAnimal.showStatus());\n\n// Membuat instance dari child classes\nconst kitty = new Cat('Kitty');\nkitty.makeSound(); // Method dari parent\nkitty.scratch(); // Method khusus Cat\nkitty.climb(); // Method khusus Cat\nconsole.log(kitty.showStatus()); // Method dari parent\n\nconst buddy = new Dog('Buddy');\nbuddy.makeSound(); // Method dari parent\nbuddy.fetch(); // Method khusus Dog\nbuddy.guard(); // Method khusus Dog\nconsole.log(buddy.showStatus()); // Method dari parent\n\n// Eksplorasi: Membuat class Fish\nconst Animal = require('./animal');\n\nclass Fish extends Animal {\n  constructor(name) {\n    super(name, 'Ikan', 'Blub');\n  }\n  \n  swim() {\n    console.log(`${this.getName()} berenang.`);\n  }\n}\n\nconst nemo = new Fish('Nemo');\nnemo.makeSound();\nnemo.swim();\nconsole.log(nemo.showStatus());\n```\n\nTambahkan komentar yang menjelaskan konsep inheritance dan penggunaan super().",
        "testStrategy": "Jalankan file index.js dengan Node.js dan verifikasi bahwa class Cat dan Dog mewarisi properties dan methods dari class Animal. Pastikan method khusus untuk masing-masing child class berfungsi dengan benar. Verifikasi bahwa super() memanggil constructor parent dengan benar.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implementasi Method Overriding",
        "description": "Menerapkan konsep method overriding dengan mengubah implementasi method dari parent class di child class.",
        "details": "Buat folder step-05-overriding dan salin file-file dari step sebelumnya, kemudian modifikasi:\n\n1. Modifikasi cat.js:\n```javascript\nconst Animal = require('./animal');\n\nclass Cat extends Animal {\n  constructor(name) {\n    super(name, 'Kucing', 'Meow');\n  }\n  \n  // Override method makeSound dari parent\n  makeSound() {\n    console.log(`${this.getName()} mengeong: Meooowww!`);\n    // Kita bisa memanggil implementasi parent jika diperlukan\n    // super.makeSound();\n  }\n  \n  // Override method move dari parent\n  move() {\n    console.log(`${this.getName()} melompat dengan anggun.`);\n    // Kita tidak memanggil super.move() sehingga implementasi sepenuhnya berbeda\n  }\n  \n  scratch() {\n    console.log(`${this.getName()} menggaruk-garuk.`);\n  }\n}\n\nmodule.exports = Cat;\n```\n\n2. Modifikasi dog.js:\n```javascript\nconst Animal = require('./animal');\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name, 'Anjing', 'Woof');\n  }\n  \n  // Override method makeSound dari parent\n  makeSound() {\n    console.log(`${this.getName()} menggonggong: Woof woof!`);\n    // Kita bisa memanggil implementasi parent jika diperlukan\n    // super.makeSound();\n  }\n  \n  // Override method move dari parent dengan menggunakan super\n  move() {\n    console.log(`${this.getName()} berlari dengan cepat.`);\n    // Memanggil implementasi parent untuk mengurangi energi dan menambah kelaparan\n    super.move();\n  }\n  \n  fetch() {\n    console.log(`${this.getName()} mengambil bola.`);\n  }\n}\n\nmodule.exports = Dog;\n```\n\n3. Buat file index.js untuk menguji overriding:\n```javascript\nconst Animal = require('./animal');\nconst Cat = require('./cat');\nconst Dog = require('./dog');\n\nconsole.log('=== Method Overriding Demo ===');\n\n// Membuat instance dari parent class\nconst genericAnimal = new Animal('Generic', 'Unknown', 'Sound');\nconsole.log('\\nGeneric Animal:');\ngenericAnimal.makeSound();\ngenericAnimal.move();\nconsole.log(genericAnimal.showStatus());\n\n// Membuat instance dari Cat class\nconst kitty = new Cat('Kitty');\nconsole.log('\\nCat:');\nkitty.makeSound(); // Overridden method\nkitty.move(); // Overridden method\nconsole.log(kitty.showStatus());\n\n// Membuat instance dari Dog class\nconst buddy = new Dog('Buddy');\nconsole.log('\\nDog:');\nbuddy.makeSound(); // Overridden method\nbuddy.move(); // Overridden method dengan super\nconsole.log(buddy.showStatus());\n\n// Menunjukkan perbedaan implementasi\nconsole.log('\\nPerbandingan move() method:');\ngenericAnimal.move();\nkitty.move();\nbuddy.move();\n```\n\nTambahkan komentar yang menjelaskan konsep method overriding dan penggunaan super dalam overridden methods.",
        "testStrategy": "Jalankan file index.js dengan Node.js dan verifikasi bahwa method makeSound() dan move() di class Cat dan Dog berhasil di-override dengan implementasi yang berbeda. Pastikan super.move() di Dog class memanggil implementasi parent dengan benar. Bandingkan output dari ketiga class untuk memastikan behavior yang berbeda.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implementasi Polymorphism dengan Array of Objects",
        "description": "Menerapkan konsep polymorphism dengan membuat array berisi object dari class berbeda dan memanggil method yang sama pada semua object.",
        "details": "Buat file zoo.js di folder step-06-polymorphism:\n\n```javascript\nconst Animal = require('../step-05-overriding/animal');\nconst Cat = require('../step-05-overriding/cat');\nconst Dog = require('../step-05-overriding/dog');\n\n// Membuat class Fish untuk menambah variasi\nclass Fish extends Animal {\n  constructor(name) {\n    super(name, 'Ikan', 'Blub');\n  }\n  \n  makeSound() {\n    console.log(`${this.getName()} membuat gelembung: Blub blub!`);\n  }\n  \n  move() {\n    console.log(`${this.getName()} berenang.`);\n  }\n  \n  performTrick() {\n    console.log(`${this.getName()} berenang memutar.`);\n  }\n}\n\n// Menambahkan method performTrick ke semua class\nAnimal.prototype.performTrick = function() {\n  console.log(`${this.getName()} tidak bisa melakukan trik.`);\n};\n\nCat.prototype.performTrick = function() {\n  console.log(`${this.getName()} berdiri dengan dua kaki.`);\n};\n\nDog.prototype.performTrick = function() {\n  console.log(`${this.getName()} berguling.`);\n};\n\n// Membuat array berisi object dari class berbeda\nconst zoo = [\n  new Animal('Generic', 'Unknown', 'Sound'),\n  new Cat('Kitty'),\n  new Dog('Buddy'),\n  new Fish('Nemo'),\n  new Cat('Whiskers'),\n  new Dog('Rex')\n];\n\nconsole.log('=== Polymorphism Demo ===');\n\n// Memanggil method yang sama pada semua object\nconsole.log('\\n1. Semua hewan bersuara:');\nzoo.forEach(animal => {\n  animal.makeSound();\n});\n\nconsole.log('\\n2. Semua hewan bergerak:');\nzoo.forEach(animal => {\n  animal.move();\n});\n\nconsole.log('\\n3. Semua hewan melakukan trik:');\nzoo.forEach(animal => {\n  animal.performTrick();\n});\n\n// Menunjukkan polymorphism dengan conditional behavior\nconsole.log('\\n4. Memberi makan berdasarkan jenis:');\nzoo.forEach(animal => {\n  const type = animal.getType();\n  if (type === 'Kucing') {\n    console.log(`Memberi ${animal.getName()} makanan kucing.`);\n  } else if (type === 'Anjing') {\n    console.log(`Memberi ${animal.getName()} makanan anjing.`);\n  } else if (type === 'Ikan') {\n    console.log(`Memberi ${animal.getName()} pelet ikan.`);\n  } else {\n    console.log(`Memberi ${animal.getName()} makanan umum.`);\n  }\n  animal.feed(10);\n});\n\n// Menampilkan status semua hewan\nconsole.log('\\n5. Status semua hewan:');\nzoo.forEach(animal => {\n  console.log(animal.showStatus());\n});\n```\n\nTambahkan komentar yang menjelaskan konsep polymorphism dan bagaimana JavaScript menentukan method mana yang harus dipanggil saat runtime.",
        "testStrategy": "Jalankan file zoo.js dengan Node.js dan verifikasi bahwa method yang sama (makeSound, move, performTrick) dapat dipanggil pada semua object dalam array, meskipun implementasinya berbeda. Pastikan setiap object merespon dengan cara yang sesuai dengan class-nya. Verifikasi bahwa conditional behavior berdasarkan type berfungsi dengan benar.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implementasi Abstract Class Concept",
        "description": "Menerapkan konsep abstract class dengan membuat class yang tidak bisa di-instantiate langsung dan memaksa child class untuk mengimplementasikan method tertentu.",
        "details": "Buat file abstract-pet.js di folder step-07-abstract:\n\n```javascript\n// Simulasi abstract class di JavaScript\nclass AbstractPet {\n  constructor(name) {\n    // Mencegah instantiasi langsung dari AbstractPet\n    if (this.constructor === AbstractPet) {\n      throw new Error('AbstractPet tidak bisa di-instantiate langsung. Gunakan child class.');\n    }\n    \n    this.name = name;\n  }\n  \n  // Abstract methods yang harus di-implement oleh child classes\n  makeSound() {\n    throw new Error('Child class harus mengimplementasikan method makeSound().');\n  }\n  \n  eat() {\n    throw new Error('Child class harus mengimplementasikan method eat().');\n  }\n  \n  sleep() {\n    throw new Error('Child class harus mengimplementasikan method sleep().');\n  }\n  \n  // Concrete method yang bisa digunakan oleh semua child classes\n  getName() {\n    return this.name;\n  }\n  \n  showInfo() {\n    console.log(`Nama: ${this.name}`);\n    console.log(`Jenis: ${this.constructor.name}`);\n  }\n}\n\n// Implementasi child class\nclass HomeCat extends AbstractPet {\n  constructor(name) {\n    super(name);\n  }\n  \n  // Implementasi abstract methods\n  makeSound() {\n    console.log(`${this.name} mengeong: Meow!`);\n  }\n  \n  eat() {\n    console.log(`${this.name} makan makanan kucing.`);\n  }\n  \n  sleep() {\n    console.log(`${this.name} tidur di sofa.`);\n  }\n  \n  // Method tambahan khusus HomeCat\n  playWithToy() {\n    console.log(`${this.name} bermain dengan mainan.`);\n  }\n}\n\n// Implementasi child class lain\nclass HomeRabbit extends AbstractPet {\n  constructor(name) {\n    super(name);\n  }\n  \n  // Implementasi abstract methods\n  makeSound() {\n    console.log(`${this.name} membuat suara pelan.`);\n  }\n  \n  eat() {\n    console.log(`${this.name} makan wortel.`);\n  }\n  \n  sleep() {\n    console.log(`${this.name} tidur di kandang.`);\n  }\n  \n  // Method tambahan khusus HomeRabbit\n  hop() {\n    console.log(`${this.name} melompat-lompat.`);\n  }\n}\n\n// Demo penggunaan\nconsole.log('=== Abstract Class Demo ===\\n');\n\n// Mencoba instantiate abstract class (akan error)\ntry {\n  const abstractPet = new AbstractPet('Test');\n} catch (error) {\n  console.log(`Error: ${error.message}`);\n}\n\n// Menggunakan child classes\nconst kitty = new HomeCat('Kitty');\nkitty.showInfo(); // Method dari abstract class\nkitty.makeSound(); // Implemented abstract method\nkitty.eat(); // Implemented abstract method\nkitty.sleep(); // Implemented abstract method\nkitty.playWithToy(); // Method khusus HomeCat\n\nconsole.log();\n\nconst bunny = new HomeRabbit('Bunny');\nbunny.showInfo(); // Method dari abstract class\nbunny.makeSound(); // Implemented abstract method\nbunny.eat(); // Implemented abstract method\nbunny.sleep(); // Implemented abstract method\nbunny.hop(); // Method khusus HomeRabbit\n\n// Mencoba memanggil method yang tidak diimplementasikan\nclass IncompleteImplementation extends AbstractPet {\n  constructor(name) {\n    super(name);\n  }\n  \n  // Hanya mengimplementasikan satu abstract method\n  makeSound() {\n    console.log('Some sound');\n  }\n  // eat() dan sleep() tidak diimplementasikan\n}\n\nconsole.log('\\nMencoba class dengan implementasi tidak lengkap:');\nconst incomplete = new IncompleteImplementation('Incomplete');\ntry {\n  incomplete.eat(); // Akan throw error\n} catch (error) {\n  console.log(`Error: ${error.message}`);\n}\n\nmodule.exports = { AbstractPet, HomeCat, HomeRabbit };\n```\n\nTambahkan komentar yang menjelaskan konsep abstract class dan mengapa abstract class tidak bisa di-instantiate langsung.",
        "testStrategy": "Jalankan file abstract-pet.js dengan Node.js dan verifikasi bahwa AbstractPet tidak bisa di-instantiate langsung (harus throw error). Pastikan child classes (HomeCat dan HomeRabbit) mengimplementasikan semua abstract methods dengan benar. Verifikasi bahwa IncompleteImplementation class throw error saat memanggil method yang tidak diimplementasikan.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implementasi Composition Pattern",
        "description": "Menerapkan konsep composition dengan membuat object yang berisi object lain, menunjukkan hubungan 'has-a' daripada inheritance.",
        "details": "Buat dua file di folder step-08-composition:\n\n1. owner.js:\n```javascript\nclass Owner {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.pets = []; // Array untuk menyimpan pets yang dimiliki\n  }\n  \n  addPet(pet) {\n    this.pets.push(pet);\n    console.log(`${this.name} sekarang memiliki pet baru: ${pet.getName()}`);\n  }\n  \n  feedAllPets() {\n    if (this.pets.length === 0) {\n      console.log(`${this.name} tidak memiliki pet.`);\n      return;\n    }\n    \n    console.log(`${this.name} memberi makan semua pets:`);\n    this.pets.forEach(pet => {\n      console.log(`- Memberi makan ${pet.getName()}`);\n      pet.feed(20);\n    });\n  }\n  \n  playWithPet(petName) {\n    const pet = this.pets.find(p => p.getName() === petName);\n    if (pet) {\n      console.log(`${this.name} bermain dengan ${pet.getName()}`);\n      pet.play(15);\n    } else {\n      console.log(`${this.name} tidak memiliki pet bernama ${petName}`);\n    }\n  }\n  \n  showAllPets() {\n    if (this.pets.length === 0) {\n      console.log(`${this.name} tidak memiliki pet.`);\n      return;\n    }\n    \n    console.log(`${this.name} memiliki ${this.pets.length} pets:`);\n    this.pets.forEach(pet => {\n      console.log(`- ${pet.getName()} (${pet.getType()})`);\n    });\n  }\n}\n\nmodule.exports = Owner;\n```\n\n2. pet-shop.js:\n```javascript\nconst Animal = require('../step-05-overriding/animal');\nconst Cat = require('../step-05-overriding/cat');\nconst Dog = require('../step-05-overriding/dog');\nconst Owner = require('./owner');\n\nclass PetShop {\n  constructor(name) {\n    this.name = name;\n    this.availablePets = [];\n    this.owners = [];\n  }\n  \n  addPet(pet) {\n    this.availablePets.push(pet);\n    console.log(`${pet.getName()} (${pet.getType()}) ditambahkan ke ${this.name}`);\n  }\n  \n  registerOwner(owner) {\n    this.owners.push(owner);\n    console.log(`${owner.name} terdaftar di ${this.name}`);\n  }\n  \n  sellPet(petName, ownerName) {\n    // Cari pet berdasarkan nama\n    const petIndex = this.availablePets.findIndex(p => p.getName() === petName);\n    if (petIndex === -1) {\n      console.log(`Pet dengan nama ${petName} tidak tersedia.`);\n      return false;\n    }\n    \n    // Cari owner berdasarkan nama\n    const owner = this.owners.find(o => o.name === ownerName);\n    if (!owner) {\n      console.log(`Owner dengan nama ${ownerName} tidak terdaftar.`);\n      return false;\n    }\n    \n    // Jual pet ke owner\n    const pet = this.availablePets[petIndex];\n    owner.addPet(pet);\n    this.availablePets.splice(petIndex, 1);\n    console.log(`${petName} berhasil dijual ke ${ownerName}!`);\n    return true;\n  }\n  \n  showAvailablePets() {\n    if (this.availablePets.length === 0) {\n      console.log(`${this.name} tidak memiliki pet yang tersedia.`);\n      return;\n    }\n    \n    console.log(`Pets yang tersedia di ${this.name}:`);\n    this.availablePets.forEach(pet => {\n      console.log(`- ${pet.getName()} (${pet.getType()})`);\n    });\n  }\n  \n  showOwners() {\n    if (this.owners.length === 0) {\n      console.log(`${this.name} belum memiliki owner terdaftar.`);\n      return;\n    }\n    \n    console.log(`Owners terdaftar di ${this.name}:`);\n    this.owners.forEach(owner => {\n      console.log(`- ${owner.name}`);\n    });\n  }\n}\n\n// Demo penggunaan composition\nconsole.log('=== Composition Demo ===\\n');\n\n// Membuat pet shop\nconst happyPets = new PetShop('Happy Pets');\n\n// Menambahkan pets ke pet shop\nhappyPets.addPet(new Cat('Whiskers'));\nhappyPets.addPet(new Cat('Mittens'));\nhappyPets.addPet(new Dog('Buddy'));\nhappyPets.addPet(new Dog('Rex'));\n\n// Mendaftarkan owners\nconst john = new Owner('John', 30);\nconst sarah = new Owner('Sarah', 25);\nhappyPets.registerOwner(john);\nhappyPets.registerOwner(sarah);\n\n// Menampilkan pets dan owners\nconsole.log();\nhappyPets.showAvailablePets();\nhappyPets.showOwners();\n\n// Menjual pets ke owners\nconsole.log();\nhappyPets.sellPet('Whiskers', 'John');\nhappyPets.sellPet('Buddy', 'Sarah');\n\n// Menampilkan pets yang tersisa\nconsole.log();\nhappyPets.showAvailablePets();\n\n// Owners berinteraksi dengan pets mereka\nconsole.log();\njohn.showAllPets();\njohn.feedAllPets();\njohn.playWithPet('Whiskers');\n\nconsole.log();\nsarah.showAllPets();\nsarah.feedAllPets();\nsarah.playWithPet('Buddy');\n\n// Mencoba menjual pet yang tidak tersedia\nconsole.log();\nhappyPets.sellPet('Fluffy', 'John'); // Pet tidak tersedia\n\n// Mencoba menjual ke owner yang tidak terdaftar\nconsole.log();\nhappyPets.sellPet('Mittens', 'Mike'); // Owner tidak terdaftar\n\nmodule.exports = { PetShop };\n```\n\nTambahkan komentar yang menjelaskan konsep composition dan kapan menggunakan composition vs inheritance.",
        "testStrategy": "Jalankan file pet-shop.js dengan Node.js dan verifikasi bahwa PetShop berhasil mengelola Owner dan Animal objects. Pastikan Owner dapat mengelola multiple Pet objects. Verifikasi bahwa semua interaksi antar objects berfungsi dengan benar (menjual pet, memberi makan pet, bermain dengan pet). Pastikan error handling berfungsi dengan benar untuk kasus-kasus seperti pet tidak tersedia atau owner tidak terdaftar.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implementasi Static Members",
        "description": "Menerapkan konsep static properties dan methods yang dimiliki oleh Class, bukan instance.",
        "details": "Buat file animal-registry.js di folder step-09-static:\n\n```javascript\nclass Animal {\n  // Instance properties\n  name;\n  type;\n  energy = 100;\n  hunger = 50;\n  \n  // Static property - shared across all instances\n  static animalCount = 0;\n  static animalTypes = {};\n  \n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n    \n    // Increment animal count when new animal is created\n    Animal.animalCount++;\n    \n    // Track count per type\n    if (Animal.animalTypes[type]) {\n      Animal.animalTypes[type]++;\n    } else {\n      Animal.animalTypes[type] = 1;\n    }\n    \n    console.log(`${name} (${type}) created. Total animals: ${Animal.animalCount}`);\n  }\n  \n  // Instance methods\n  makeSound(sound) {\n    console.log(`${this.name} berbunyi: ${sound}`);\n  }\n  \n  feed(amount) {\n    this.hunger = Math.max(0, this.hunger - amount);\n    console.log(`${this.name} diberi makan. Kelaparan: ${this.hunger}`);\n  }\n  \n  // Static methods\n  static getAnimalCount() {\n    return Animal.animalCount;\n  }\n  \n  static getTypeCount(type) {\n    return Animal.animalTypes[type] || 0;\n  }\n  \n  static compareEnergy(animal1, animal2) {\n    if (animal1.energy > animal2.energy) {\n      return `${animal1.name} memiliki energi lebih banyak daripada ${animal2.name}`;\n    } else if (animal1.energy < animal2.energy) {\n      return `${animal2.name} memiliki energi lebih banyak daripada ${animal1.name}`;\n    } else {\n      return `${animal1.name} dan ${animal2.name} memiliki energi yang sama`;\n    }\n  }\n  \n  static createAnimal(name, type, sound) {\n    const animal = new Animal(name, type);\n    animal.makeSound(sound);\n    return animal;\n  }\n  \n  static validateName(name) {\n    return typeof name === 'string' && name.length > 0;\n  }\n}\n\n// Demo penggunaan static members\nconsole.log('=== Static Members Demo ===\\n');\n\n// Mengakses static property sebelum membuat instance\nconsole.log(`Jumlah hewan awal: ${Animal.animalCount}`);\n\n// Membuat beberapa instance\nconst cat1 = new Animal('Whiskers', 'Kucing');\nconst cat2 = new Animal('Mittens', 'Kucing');\nconst dog1 = new Animal('Buddy', 'Anjing');\nconst dog2 = new Animal('Rex', 'Anjing');\nconst rabbit = new Animal('Fluffy', 'Kelinci');\n\n// Mengakses static property setelah membuat instance\nconsole.log(`\\nJumlah hewan total: ${Animal.animalCount}`);\nconsole.log(`Jumlah kucing: ${Animal.getTypeCount('Kucing')}`);\nconsole.log(`Jumlah anjing: ${Animal.getTypeCount('Anjing')}`);\nconsole.log(`Jumlah kelinci: ${Animal.getTypeCount('Kelinci')}`);\n\n// Menggunakan static method untuk membandingkan animals\ncat1.energy = 80;\ndog1.energy = 90;\nconsole.log(`\\n${Animal.compareEnergy(cat1, dog1)}`);\n\n// Menggunakan static method untuk validasi\nconsole.log(`\\nValidasi nama 'Rex': ${Animal.validateName('Rex')}`);\nconsole.log(`Validasi nama '': ${Animal.validateName('')}`);\nconsole.log(`Validasi nama 123: ${Animal.validateName(123)}`);\n\n// Menggunakan static factory method\nconsole.log('\\nMembuat hewan baru menggunakan static factory method:');\nconst fish = Animal.createAnimal('Nemo', 'Ikan', 'Blub');\n\n// Eksplorasi: Static constants\nAnimal.MAXIMUM_ENERGY = 100;\nAnimal.SPECIES_TYPES = ['Mammal', 'Bird', 'Fish', 'Reptile', 'Amphibian'];\n\nconsole.log(`\\nMaximum energy: ${Animal.MAXIMUM_ENERGY}`);\nconsole.log(`Species types: ${Animal.SPECIES_TYPES.join(', ')}`);\n\nmodule.exports = Animal;\n```\n\nTambahkan komentar yang menjelaskan konsep static members dan kapan menggunakan static vs instance members.",
        "testStrategy": "Jalankan file animal-registry.js dengan Node.js dan verifikasi bahwa static properties (animalCount, animalTypes) diincrement dengan benar saat membuat instance baru. Pastikan static methods (getAnimalCount, getTypeCount, compareEnergy, createAnimal, validateName) berfungsi dengan benar. Verifikasi bahwa static members dapat diakses tanpa membuat instance dari class.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implementasi Mini Pet Simulation",
        "description": "Mengintegrasikan semua konsep OOP yang telah dipelajari dalam satu aplikasi simulasi hewan peliharaan sederhana.",
        "details": "Buat file pet-sim.js di folder step-10-simulation:\n\n```javascript\n// Mengimpor semua konsep yang telah dipelajari\nconst { AbstractPet, HomeCat, HomeRabbit } = require('../step-07-abstract/abstract-pet');\nconst { PetShop } = require('../step-08-composition/pet-shop');\nconst AnimalRegistry = require('../step-09-static/animal-registry');\n\n// Class untuk Pet Owner dengan composition\nclass PetOwner {\n  #name;\n  #pets = [];\n  #money;\n  \n  constructor(name, initialMoney) {\n    this.#name = name;\n    this.#money = initialMoney;\n    console.log(`${name} dibuat dengan uang ${initialMoney}.`);\n  }\n  \n  getName() {\n    return this.#name;\n  }\n  \n  getMoney() {\n    return this.#money;\n  }\n  \n  addPet(pet) {\n    this.#pets.push(pet);\n    console.log(`${this.#name} menambahkan pet baru: ${pet.getName()}.`);\n  }\n  \n  buyPet(petShop, petName, price) {\n    if (this.#money < price) {\n      console.log(`${this.#name} tidak punya cukup uang untuk membeli ${petName}.`);\n      return false;\n    }\n    \n    const success = petShop.sellPet(petName, this.#name, price);\n    if (success) {\n      this.#money -= price;\n      console.log(`${this.#name} membeli ${petName} seharga ${price}. Sisa uang: ${this.#money}.`);\n      return true;\n    }\n    \n    return false;\n  }\n  \n  interactWithPets() {\n    if (this.#pets.length === 0) {\n      console.log(`${this.#name} tidak punya pet.`);\n      return;\n    }\n    \n    console.log(`\\n${this.#name} berinteraksi dengan pets:`);\n    this.#pets.forEach(pet => {\n      pet.makeSound();\n      pet.eat();\n      \n      // Polymorphism - setiap pet punya implementasi berbeda\n      if (pet instanceof HomeCat) {\n        pet.playWithToy();\n      } else if (pet instanceof HomeRabbit) {\n        pet.hop();\n      }\n    });\n  }\n  \n  showPets() {\n    if (this.#pets.length === 0) {\n      console.log(`${this.#name} tidak punya pet.`);\n      return;\n    }\n    \n    console.log(`\\n${this.#name} memiliki ${this.#pets.length} pets:`);\n    this.#pets.forEach(pet => {\n      console.log(`- ${pet.getName()} (${pet.constructor.name})`);\n    });\n  }\n}\n\n// Class untuk Pet Shop dengan static tracking\nclass EnhancedPetShop {\n  static shopCount = 0;\n  \n  #name;\n  #availablePets = [];\n  #registeredOwners = [];\n  #salesHistory = [];\n  \n  constructor(name) {\n    this.#name = name;\n    EnhancedPetShop.shopCount++;\n    console.log(`Pet shop '${name}' dibuat. Total pet shops: ${EnhancedPetShop.shopCount}.`);\n  }\n  \n  getName() {\n    return this.#name;\n  }\n  \n  addPet(pet, price) {\n    this.#availablePets.push({ pet, price });\n    console.log(`${pet.getName()} ditambahkan ke ${this.#name} dengan harga ${price}.`);\n  }\n  \n  registerOwner(owner) {\n    if (this.#registeredOwners.find(o => o.getName() === owner.getName())) {\n      console.log(`${owner.getName()} sudah terdaftar di ${this.#name}.`);\n      return false;\n    }\n    \n    this.#registeredOwners.push(owner);\n    console.log(`${owner.getName()} terdaftar di ${this.#name}.`);\n    return true;\n  }\n  \n  sellPet(petName, ownerName, price) {\n    // Cari pet berdasarkan nama\n    const petIndex = this.#availablePets.findIndex(item => item.pet.getName() === petName);\n    if (petIndex === -1) {\n      console.log(`Pet dengan nama ${petName} tidak tersedia di ${this.#name}.`);\n      return false;\n    }\n    \n    // Cari owner berdasarkan nama\n    const owner = this.#registeredOwners.find(o => o.getName() === ownerName);\n    if (!owner) {\n      console.log(`Owner dengan nama ${ownerName} tidak terdaftar di ${this.#name}.`);\n      return false;\n    }\n    \n    // Verifikasi harga\n    const petItem = this.#availablePets[petIndex];\n    if (price < petItem.price) {\n      console.log(`Harga yang ditawarkan (${price}) kurang dari harga pet (${petItem.price}).`);\n      return false;\n    }\n    \n    // Jual pet ke owner\n    owner.addPet(petItem.pet);\n    this.#availablePets.splice(petIndex, 1);\n    \n    // Catat penjualan\n    this.#salesHistory.push({\n      date: new Date(),\n      petName,\n      ownerName,\n      price\n    });\n    \n    console.log(`${petName} berhasil dijual ke ${ownerName} seharga ${price}!`);\n    return true;\n  }\n  \n  showAvailablePets() {\n    if (this.#availablePets.length === 0) {\n      console.log(`${this.#name} tidak memiliki pet yang tersedia.`);\n      return;\n    }\n    \n    console.log(`\\nPets yang tersedia di ${this.#name}:`);\n    this.#availablePets.forEach(item => {\n      console.log(`- ${item.pet.getName()} (${item.pet.constructor.name}) - Harga: ${item.price}`);\n    });\n  }\n  \n  showSalesHistory() {\n    if (this.#salesHistory.length === 0) {\n      console.log(`${this.#name} belum melakukan penjualan.`);\n      return;\n    }\n    \n    console.log(`\\nRiwayat penjualan ${this.#name}:`);\n    this.#salesHistory.forEach((sale, index) => {\n      console.log(`${index + 1}. ${sale.petName} -> ${sale.ownerName} (${sale.price}) pada ${sale.date.toLocaleString()}`);\n    });\n  }\n  \n  static getTotalShops() {\n    return EnhancedPetShop.shopCount;\n  }\n}\n\n// Simulasi Pet Shop\nconsole.log('=== Pet Simulation ===\\n');\n\n// Membuat pet shop\nconst happyPets = new EnhancedPetShop('Happy Pets');\nconst luxuryPets = new EnhancedPetShop('Luxury Pets');\n\n// Membuat owners\nconst john = new PetOwner('John', 1000);\nconst sarah = new PetOwner('Sarah', 1500);\n\n// Mendaftarkan owners ke pet shops\nhappyPets.registerOwner(john);\nhappyPets.registerOwner(sarah);\nluxuryPets.registerOwner(sarah);\n\n// Menambahkan pets ke pet shops\nhappyPets.addPet(new HomeCat('Whiskers'), 300);\nhappyPets.addPet(new HomeCat('Mittens'), 350);\nhappyPets.addPet(new HomeRabbit('Fluffy'), 200);\n\nluxuryPets.addPet(new HomeCat('Princess'), 800);\nluxuryPets.addPet(new HomeRabbit('King'), 600);\n\n// Menampilkan pets yang tersedia\nhappyPets.showAvailablePets();\nluxuryPets.showAvailablePets();\n\n// Owners membeli pets\nconsole.log('\\n=== Transaksi Pembelian ===');\njohn.buyPet(happyPets, 'Whiskers', 300);\nsarah.buyPet(happyPets, 'Fluffy', 200);\nsarah.buyPet(luxuryPets, 'Princess', 800);\n\n// Mencoba transaksi yang gagal\njohn.buyPet(happyPets, 'Mittens', 200); // Harga kurang\njohn.buyPet(luxuryPets, 'King', 600); // John tidak terdaftar di luxuryPets\n\n// Menampilkan pets yang tersisa\nhappyPets.showAvailablePets();\nluxuryPets.showAvailablePets();\n\n// Menampilkan riwayat penjualan\nhappyPets.showSalesHistory();\nluxuryPets.showSalesHistory();\n\n// Owners berinteraksi dengan pets mereka\njohn.showPets();\njohn.interactWithPets();\n\nsarah.showPets();\nsarah.interactWithPets();\n\n// Menampilkan informasi static\nconsole.log(`\\nTotal pet shops: ${EnhancedPetShop.getTotalShops()}`);\n\n// Game loop sederhana (simulasi)\nconsole.log('\\n=== Simulasi Interaksi ===');\n\nfunction simulateDay() {\n  console.log('\\n--- Hari Baru ---');\n  \n  // Owners berinteraksi dengan pets mereka\n  john.interactWithPets();\n  sarah.interactWithPets();\n  \n  // Pet shop menambahkan pet baru secara random\n  if (Math.random() > 0.5) {\n    const newPet = Math.random() > 0.5 \n      ? new HomeCat(`Cat${Math.floor(Math.random() * 100)}`) \n      : new HomeRabbit(`Rabbit${Math.floor(Math.random() * 100)}`);\n    \n    const price = 200 + Math.floor(Math.random() * 500);\n    const shop = Math.random() > 0.5 ? happyPets : luxuryPets;\n    \n    shop.addPet(newPet, price);\n  }\n  \n  // Kemungkinan owner membeli pet baru\n  if (Math.random() > 0.7) {\n    const shop = Math.random() > 0.5 ? happyPets : luxuryPets;\n    shop.showAvailablePets();\n    \n    if (Math.random() > 0.5 && john.getMoney() > 0) {\n      // John mencoba membeli pet random\n      const availablePets = shop.showAvailablePets();\n      if (availablePets && availablePets.length > 0) {\n        const randomPet = availablePets[0];\n        john.buyPet(shop, randomPet.pet.getName(), randomPet.price);\n      }\n    } else if (sarah.getMoney() > 0) {\n      // Sarah mencoba membeli pet random\n      const availablePets = shop.showAvailablePets();\n      if (availablePets && availablePets.length > 0) {\n        const randomPet = availablePets[0];\n        sarah.buyPet(shop, randomPet.pet.getName(), randomPet.price);\n      }\n    }\n  }\n}\n\n// Simulasi beberapa hari\nfor (let day = 1; day <= 3; day++) {\n  simulateDay();\n}\n\nconsole.log('\\n=== Simulasi Selesai ===');\n```\n\nTambahkan komentar yang menjelaskan bagaimana semua konsep OOP diintegrasikan dalam simulasi ini.",
        "testStrategy": "Jalankan file pet-sim.js dengan Node.js dan verifikasi bahwa semua konsep OOP (class, object, encapsulation, inheritance, polymorphism, abstract class, composition, static members) diimplementasikan dengan benar dalam simulasi. Pastikan simulasi berjalan tanpa error dan menghasilkan output yang diharapkan. Verifikasi bahwa interaksi antar objects (PetOwner, EnhancedPetShop, HomeCat, HomeRabbit) berfungsi dengan benar.",
        "priority": "high",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-05T03:12:48.316Z",
      "updated": "2025-08-06T02:54:19.962Z",
      "description": "Tasks for master context"
    }
  }
}